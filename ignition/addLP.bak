// SPDX-License-Identifier: MIT
pragma solidity ^0.8.26;

import {console2} from "forge-std/Script.sol";
import {IERC20} from "forge-std/interfaces/IERC20.sol";
import {ScaffoldETHDeploy} from "./DeployHelpers.s.sol";

import {IPoolManager} from "@uniswap/v4-core/src/interfaces/IPoolManager.sol";
import {PoolKey} from "@uniswap/v4-core/src/types/PoolKey.sol";
import {CurrencyLibrary, Currency} from "@uniswap/v4-core/src/types/Currency.sol";
import {IHooks} from "@uniswap/v4-core/src/interfaces/IHooks.sol";
import {Actions} from "lib/v4-periphery/src/libraries/Actions.sol";
import {LiquidityAmounts} from "lib/v4-core/test/utils/LiquidityAmounts.sol";
import {TickMath} from "lib/v4-core/src/libraries/TickMath.sol";
import {StateLibrary} from "lib/v4-core/src/libraries/StateLibrary.sol";
import {IPositionManager} from "lib/v4-periphery/src/interfaces/IPositionManager.sol";


contract AddLiquidityScript is ScaffoldETHDeploy  {
    using CurrencyLibrary for Currency;
    using StateLibrary for IPoolManager;

    /////////////////////////////////////
    // --- Configure These ---
    /////////////////////////////////////

    uint24 lpFee = 3000; // 0.30%
    int24 tickSpacing = 60;

    // --- liquidity position configuration --- //
    uint256 public token0Amount = 1e18;
    uint256 public token1Amount = 1e18;

    /////////////////////////////////////

    int24 tickLower;
    int24 tickUpper;

    // Hardcoded addresses for Sepolia testnet
    address constant POSITION_MANAGER_ADDRESS = 0x8c8Bf5DEa2801be144796E4DeA1Ab7E087f90BCd;
    address constant V4_SWAP_ROUTER_ADDRESS = 0x3bFA4769FB09eefC5a80d6E87c3B9C650f7Ae48E;

    function run() external {
        address TOKEN0_ADDRESS = address(0x083dC0B99F583B5F6eD9c86612B3CcB8e8845b4A);
        address TOKEN1_ADDRESS = address(0x6550c8d40f06c8A5B003A0622538980Fc4AF7492);
        address HOOK_ADDRESS = address(0xCA2A914BA5fdFaaD2989CC21A93F172701078080);
        address POOL_MANAGER_ADDRESS = address(0xE03A1074c86CFeDd5C142C4F04F1a1536e203543);

        Currency currency0 = Currency.wrap(TOKEN0_ADDRESS);
        Currency currency1 = Currency.wrap(TOKEN1_ADDRESS);
        IHooks hookContract = IHooks(HOOK_ADDRESS);
        PoolKey memory poolKey = PoolKey({
            currency0: currency0,
            currency1: currency1,
            fee: lpFee,
            tickSpacing: tickSpacing,
            hooks: hookContract
        });
        bytes memory hookData = new bytes(0);

        IPoolManager poolManager = IPoolManager(POOL_MANAGER_ADDRESS);
        IPositionManager positionManager = IPositionManager(payable(POSITION_MANAGER_ADDRESS));

        address deployerAddress = getDeployer();

        (uint160 sqrtPriceX96,,,) = poolManager.getSlot0(poolKey.toId());

        int24 currentTick = TickMath.getTickAtSqrtPrice(sqrtPriceX96);

        tickLower = ((currentTick - 1000 * tickSpacing) / tickSpacing) * tickSpacing;
        tickUpper = ((currentTick + 1000 * tickSpacing) / tickSpacing) * tickSpacing;

        // Converts token amounts to liquidity units
        uint128 liquidity = LiquidityAmounts.getLiquidityForAmounts(
            sqrtPriceX96,
            TickMath.getSqrtPriceAtTick(tickLower),
            TickMath.getSqrtPriceAtTick(tickUpper),
            token0Amount,
            token1Amount
        );

        // slippage limits
        uint256 amount0Max = token0Amount + 1 wei;
        uint256 amount1Max = token1Amount + 1 wei;

        (bytes memory actions, bytes[] memory mintParams) = _mintLiquidityParams(
            poolKey, tickLower, tickUpper, liquidity, amount0Max, amount1Max, deployerAddress, hookData
        );

        // multicall parameters
        bytes[] memory params = new bytes[](1);

        // Mint Liquidity
        params[0] = abi.encodeWithSelector(
            positionManager.modifyLiquidities.selector, abi.encode(actions, mintParams), block.timestamp + 60
        );

        // If the pool is an ETH pair, native tokens are to be transferred
        uint256 valueToPass = currency0.isAddressZero() ? amount0Max : 0;

        vm.startBroadcast();
        tokenApprovals();

        // Add liquidity to existing pool
        positionManager.multicall{value: valueToPass}(params);
        vm.stopBroadcast();
    }

    function _mintLiquidityParams(
        PoolKey memory poolKey,
        int24 tickLower,
        int24 tickUpper,
        uint128 liquidity,
        uint256 amount0Max,
        uint256 amount1Max,
        address recipient,
        bytes memory hookData
    ) internal pure returns (bytes memory actions, bytes[] memory mintParams) {
        // Create actions array with MINT_POSITION action
        actions = new bytes(1);
        actions[0] = bytes1(uint8(Actions.MINT_POSITION));

        // Create params array with mint parameters
        mintParams = new bytes[](1);
        mintParams[0] = abi.encode(
            poolKey,
            tickLower,
            tickUpper,
            liquidity,
            uint128(amount0Max),
            uint128(amount1Max),
            recipient,
            hookData
        );
    }

    function tokenApprovals() internal {
        // Approve tokens for the position manager
        IERC20 token0 = IERC20(address(0x083dC0B99F583B5F6eD9c86612B3CcB8e8845b4A));
        IERC20 token1 = IERC20(address(0x6550c8d40f06c8A5B003A0622538980Fc4AF7492));
        
        token0.approve(POSITION_MANAGER_ADDRESS, type(uint256).max);
        token1.approve(POSITION_MANAGER_ADDRESS, type(uint256).max);
    }

    function getDeployer() internal returns (address) {
        address[] memory wallets = vm.getWallets();
        require(wallets.length > 0, "No wallets found");
        return wallets[0];
    }
}